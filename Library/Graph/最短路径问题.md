# 最短路径问题

## 无权图的单源最短路算法
```cpp
void unweightShortPath(Graph & graph, int Source, int dict[], int path[]) {
    int collected[MaxVertexNum] = {0}, currentVertex;
    queue<int> s;
    //初始化dict和path 
    for (int i = 0; i < graph.NumVertex; i++) {
        dict[i] = MaxWeight;
        path[i] = Source;
    }
    
    collected[Source] = 1;
    dict[Source] = 0;
    s.push(Source);
    while(s.size()) {
        currentVertex = s.front();
        s.pop();
        for (int i = 0; i < graph.NumVertex; i++)
            if (!collected[i] && graph.G[currentVertex][i] < MaxWeight) {
                s.push(i);
                dict[i] = dict[currentVertex] + 1;
                path[i] = currentVertex;
                collected[i] = 1;
            }
    }
}
```

## 有权图的单源最短路算法-Dijkstra
```cpp
int findMinDict(Graph &graph, int dict[], int collection[]) {
    int minDict = MaxWeight, minDictIndex = -1;
    for (int i = 0; i < graph.NumVertex; i ++)
        if (!collection[i] && dict[i] < minDict) {
            minDict = dict[i];
            minDictIndex = i;
        }
    return minDictIndex;
}

void Dijkstra(Graph &graph, int Source, int dict[], int path[]) {
    int collection[MaxVertexNum] = {0}, minDict;
    //初始化dict和path 
    for (int i = 0; i < graph.NumVertex; i ++) {
        dict[i] = graph.G[Source][i];
        path[i] = Source;
    }
    collection[Source] = 1;
    dict[Source] = 0;
    while(1) {
        minDict = findMinDict(graph, dict, collection);
        if (minDict == -1)
            return;
        collection[minDict] = 1;
        for (int i = 0; i < graph.NumVertex; i++)
            if (!collection[i] && dict[i] > dict[minDict] + graph.G[minDict][i]) {
                dict[i] = graph.G[minDict][i];
                path[i] = minDict;
            }   
    }
} 

```

## 有权图的单源最短路算法-Floyd

```cpp
/* 邻接矩阵存储 - 多源最短路算法 */

bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )
{
    Vertex i, j, k;

    /* 初始化 */
    for ( i=0; i<Graph->Nv; i++ )
        for( j=0; j<Graph->Nv; j++ ) {
            D[i][j] = Graph->G[i][j];
            path[i][j] = -1;
        }

    for( k=0; k<Graph->Nv; k++ )
        for( i=0; i<Graph->Nv; i++ )
            for( j=0; j<Graph->Nv; j++ )
                if( D[i][k] + D[k][j] < D[i][j] ) {
                    D[i][j] = D[i][k] + D[k][j];
                    if ( i==j && D[i][j]<0 ) /* 若发现负值圈 */
                        return false; /* 不能正确解决，返回错误标记 */
                    path[i][j] = k;
                }
    return true; /* 算法执行完毕，返回正确标记 */
}
```
