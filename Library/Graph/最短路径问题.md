# 最短路径问题

## 无权图的单源最短路算法
```cpp
/* 邻接表存储 - 无权图的单源最短路算法 */

/* dist[]和path[]全部初始化为-1 */
void Unweighted ( LGraph Graph, int dist[], int path[], Vertex S )
{
    Queue Q;
    Vertex V;
    PtrToAdjVNode W;

    Q = CreateQueue( Graph->Nv ); /* 创建空队列, MaxSize为外部定义的常数 */
    dist[S] = 0; /* 初始化源点 */
    AddQ (Q, S);

    while( !IsEmpty(Q) ){
        V = DeleteQ(Q);
        for ( W=Graph->G[V].FirstEdge; W; W=W->Next ) /* 对V的每个邻接点W->AdjV */
            if ( dist[W->AdjV]==-1 ) { /* 若W->AdjV未被访问过 */
                dist[W->AdjV] = dist[V]+1; /* W->AdjV到S的距离更新 */
                path[W->AdjV] = V; /* 将V记录在S到W->AdjV的路径上 */
                AddQ(Q, W->AdjV);
            }
    } /* while结束*/
}
```

## 有权图的单源最短路算法-Dijkstra
```cpp
void Dijkstra(Graph &graph, int Source, int dict[], int path[]) {
    int collection[MaxVertexNum] = {0}, minDict;
    for (int i = 0; i < graph.NumVertex; i ++) {
        dict[i] = graph.G[Source][i];
        path[i] = Source;
    }
    collection[Source] = 1;
    while(1) {
        minDict = findMinDict(graph, dict, collection);
        if (minDict == -1)
            return;
        collection[minDict] = 1;
        for (int i = 0; i < graph.NumVertex; i++)
            if (!collection[i] && dict[i] > dict[minDict] + graph.G[minDict][i]) {
                dict[i] = graph.G[minDict][i];
                path[i] = minDict;
            }   
    }
} 
```

## 有权图的单源最短路算法-Floyd

```cpp
/* 邻接矩阵存储 - 多源最短路算法 */

bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )
{
    Vertex i, j, k;

    /* 初始化 */
    for ( i=0; i<Graph->Nv; i++ )
        for( j=0; j<Graph->Nv; j++ ) {
            D[i][j] = Graph->G[i][j];
            path[i][j] = -1;
        }

    for( k=0; k<Graph->Nv; k++ )
        for( i=0; i<Graph->Nv; i++ )
            for( j=0; j<Graph->Nv; j++ )
                if( D[i][k] + D[k][j] < D[i][j] ) {
                    D[i][j] = D[i][k] + D[k][j];
                    if ( i==j && D[i][j]<0 ) /* 若发现负值圈 */
                        return false; /* 不能正确解决，返回错误标记 */
                    path[i][j] = k;
                }
    return true; /* 算法执行完毕，返回正确标记 */
}
```
